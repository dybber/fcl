-- | Untyped constructors for building GPUIL-kernels
module Language.GPUIL.Cons (
  
 -- Types
 int, double, bool, word8, word32, pointer,

 -- Expressions
 constant, if_, (?), let_, letVar, index, (!), cast,
 -- Getter's (launch parameters and current thread info)
 globalID, localID, localSize, workgroupID, numWorkgroups,
 var,

 -- Operators
 addi, subi, muli, divi, modi,
 addd, subd, muld, divd,
 lti, ltei, gti, gtei, eqi, neqi,
 ltd, lted, gtd, gted, eqd, neqd,
 land, lor, xor, sll, srl,
 (&&*), (||*),
 mini, maxi,
 
 -- Statements
 for, while, iff, distrPar, forAll,
 allocate, allocateVolatile,
 assign, (<==), assignArray,
 syncGlobal, syncLocal,

 -- Monad
 Exp,
 Type,
 Program,
 initialState,
 runProgram,
 addParam,
 generateKernel
)
where

import Data.Word (Word32, Word8)
import Control.Monad.State

import Language.GPUIL.ConvertLoops (convertLoops)
import Language.GPUIL.Syntax as AST

--------------------------------
-- Program construction monad --
--------------------------------
data MState = MState
              { params :: [VarName]
              , varCount :: Int
              , statements :: Statements () NoType
              }
initialState :: MState
initialState = MState
               { params = []
               , varCount = 0
               , statements = []
               } 

type Exp = IExp NoType
type Type = IType
type Program x = State MState x

generateKernel :: String -> Program () -> Kernel NoType
generateKernel name m =
  let finalState = runProgram m initialState
  in Kernel { kernelName = name
            , kernelParams = params finalState
            , kernelBody = convertLoops $ reverse $ statements finalState
            }

runProgram :: Program () -> MState -> MState
runProgram m init' = snd (runState m init')

addStmt :: Statement () NoType -> Program ()
addStmt stmt =
  modify (\s -> (s {statements = (stmt, ()) : statements s }))

newVar :: IType -> String -> Program VarName
newVar ty name = do
  c <- gets varCount
  modify (\s -> s { varCount = 1 + varCount s })
  return (name ++ "_" ++ show c, ty) -- the underscore is important!


----------------------
-- Variable binding --
----------------------

-- Variable binder. Creates a fresh variable, adds a declaration
-- w. initialiser and passes it on
let_ :: String -> IType -> Exp -> Program Exp
let_ name ty e = do
  v <- newVar ty name
  addStmt (Decl v (Just e))
  return (VarE v NoType)

letVar :: String -> IType -> Exp -> Program VarName
letVar name ty e = do
  v <- newVar ty name
  addStmt (Decl v (Just e))
  return v

addParam :: String -> IType -> Program VarName
addParam name ty = do
  v <- newVar ty name
  modify (\s -> s { params = v : params s })
  return v

var :: VarName -> Exp
var v = VarE v NoType
----------------
-- Statements --
----------------

-- I think these two are wrong, we should not just start with an
-- initial state, the varCount at least has to be passed on.

-- construct a for loop, where the body is generated by a function
-- taking the index variable as parameter
for :: Exp -> (Exp -> Program ()) -> Program ()
for ub f = do
  i <- newVar int "i"
  let_ "ub" int ub >>= (\upperbound -> do
    let body = statements $ runProgram (f (VarE i NoType)) initialState
                               -- TODO: Var count should be passed on!
    addStmt $ For i upperbound body)

while :: Exp -> Program () -> Program ()
while f body = 
  addStmt (SeqWhile f (statements (runProgram body initialState)))
                                    -- TODO: Var count should be passed on!

iff :: Exp -> (Program (), Program ()) -> Program ()
iff cond (f1, f2) =
  addStmt $ If cond (statements $ runProgram f1 initialState)
                    (statements $ runProgram f2 initialState)

distrPar :: Level -> Exp -> (Exp -> Program ()) -> Program ()
distrPar lvl ub f = do
  i <- newVar int "i"
  let_ "ub" int ub >>= (\upperbound -> do
    let body = statements $ runProgram (f (VarE i NoType)) initialState
    addStmt $ DistrPar lvl i upperbound body)

forAll :: Level -> Exp -> (Exp -> Program ()) -> Program ()
forAll lvl ub f = do
  i <- newVar int "i"
  let_ "ub" int ub >>= (\upperbound -> do
    let body = statements $ runProgram (f (VarE i NoType)) initialState
    addStmt $ ForAll lvl i upperbound body)


allocate :: IType -> Exp -> Program VarName
allocate ty n = do
  arr <- newVar (pointer [] ty) "arr"
  addStmt $ Allocate arr n ty
  return arr

allocateVolatile :: IType -> Exp -> Program VarName
allocateVolatile ty n = do
  arr <- newVar (pointer [Volatile] ty) "i"
  addStmt $ Allocate arr n ty
  return arr



-- assign variable, and add to current list of operators
assign :: VarName -> Exp -> Program ()
assign n e = addStmt (Assign n e)

(<==) :: VarName -> Exp -> Program ()
n <== e = assign n e

syncGlobal :: Program ()
syncGlobal =  addStmt SyncLocalMem

syncLocal :: Program ()
syncLocal =  addStmt SyncGlobalMem

-- assign to an array
assignArray :: VarName -> Exp -> Exp -> Program ()
assignArray n e idx = addStmt (AssignSub n idx e)

-----------------
--    Types    --
-----------------
int :: IType
int = Int32T

double :: IType
double = DoubleT

bool :: IType
bool = BoolT

word8 :: IType
word8 = Word8T

word32 :: IType
word32 = Word32T

pointer :: [Attribute] -> IType -> IType
pointer attr t = Ptr attr t

-----------------
-- Expressions --
-----------------
class Scalar t where
  constant :: t -> Exp

instance Scalar Int where
  constant = IntE

instance Scalar Double where
  constant = DoubleE

instance Scalar Bool where
  constant = BoolE

instance Scalar Word32 where
  constant = Word32E

instance Scalar Word8 where
  constant = Word8E

if_ :: Exp -> Exp -> Exp -> Exp
if_ econd etrue efalse =
  IfE econd etrue efalse NoType

(?) :: Exp -> (Exp, Exp) -> Exp
econd ? (e0,e1) = if_ econd e0 e1

index :: VarName -> Exp -> Exp
index n e =  IndexE n e

(!) :: VarName -> Exp -> Exp
(!) = index

-- TODO: This could be better
cast :: IType -> Exp -> Exp
cast _ e = e

globalID :: Exp
globalID = GlobalID

localID :: Exp
localID = LocalID

workgroupID :: Exp
workgroupID = GroupID

localSize :: Exp
localSize = LocalSize

numWorkgroups :: Exp
numWorkgroups =  NumGroups

-----------------
--  Operators  --
-----------------

-- Arithmetic (Int)
addi, subi, muli, divi, modi :: Exp -> Exp -> Exp
e0 `addi` e1 = (BinOpE AddI e0 e1)
e0 `subi` e1 = (BinOpE SubI e0 e1)
e0 `muli` e1 = (BinOpE MulI e0 e1)
e0 `divi` e1 = (BinOpE DivI e0 e1)
e0 `modi` e1 = (BinOpE ModI e0 e1)

-- Arithmetic (Double)
addd, subd, muld, divd :: Exp -> Exp -> Exp
e0 `addd` e1 = (BinOpE AddD e0 e1)
e0 `subd` e1 = (BinOpE SubD e0 e1)
e0 `muld` e1 = (BinOpE MulD e0 e1)
e0 `divd` e1 = (BinOpE DivD e0 e1)

-- Comparisons (Int)
lti, ltei, gti, gtei, eqi, neqi :: Exp -> Exp -> Exp
lti  e0 e1 = (BinOpE LtI e0 e1)
ltei e0 e1 = (BinOpE LteI e0 e1)
gti  e0 e1 = (BinOpE GtI e0 e1)
gtei e0 e1 = (BinOpE GteI e0 e1)
eqi  e0 e1 = (BinOpE EqI e0 e1)
neqi e0 e1 = (BinOpE NeqI e0 e1)

-- Comparisons (Double)
ltd, lted, gtd, gted, eqd, neqd  :: Exp -> Exp -> Exp
ltd  e0 e1 = (BinOpE LtD e0 e1)
lted e0 e1 = (BinOpE LteD e0 e1)
gtd  e0 e1 = (BinOpE GtD e0 e1)
gted e0 e1 = (BinOpE GteD e0 e1)
eqd  e0 e1 = (BinOpE EqD e0 e1)
neqd e0 e1 = (BinOpE NeqD e0 e1)

-- Bitwise operations
land, lor, xor, sll, srl :: Exp -> Exp -> Exp
land e0 e1 = (BinOpE Land e0 e1)
lor  e0 e1 = (BinOpE Lor e0 e1)
xor  e0 e1 = (BinOpE Xor e0 e1)
sll  e0 e1 = (BinOpE Sll e0 e1)
srl  e0 e1 = (BinOpE Srl e0 e1)

-- Boolean 'and' and 'or'
(&&*), (||*) :: Exp -> Exp -> Exp
e0 &&* e1 = (BinOpE And e0 e1)
e0 ||* e1 = (BinOpE Or e0 e1)

mini, maxi :: Exp -> Exp -> Exp
mini a b = if_ (a `lti` b) a b
maxi a b = if_ (a `lti` b) b a
