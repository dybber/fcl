{-# LANGUAGE FlexibleInstances #-}

-- | Smart constructors for building GPUIL-kernels in a safe maner
module Language.GPUIL.SmartCons (
 -- Phantom typed Exp/Type/Var
 Type, Var, Exp,
  
 -- Types
 int, double, bool, word8, word32, pointer,

 -- Expressions
 constant, if_, (?), let_, letVar, index, -- (!),
 cast,
 -- Getter's (launch parameters and current thread info)
 globalID, localID, localSize, workgroupID, numWorkgroups,
 var,

 -- Operators
 addi, subi, muli, divi, modi,
 addd, subd, muld, divd,
 lti, ltei, gti, gtei, eqi, neqi,
 ltd, lted, gtd, gted, eqd, neqd,
 land, lor, xor, sll, srl,
 (&&*), (||*),

-- ltw, minw, maxw, divw,
 
 -- Statements
 for, iff, --distrPar, forAll,
 assign, (<==), assignArray,
 syncGlobal, syncLocal,

 -- Hierarchy of parallelism
 Thread,
 Grid,
 Block,
 Warp,
 -- Monad
 Program,
 initialState,
 runProgram,
 addParam,
 generateKernel
) where

import Data.Word (Word32, Word8)
import Control.Monad.State

import Language.GPUIL.Syntax as AST

-------------------------------
-- AST nodes w. phantom types
-------------------------------
newtype Type t = T CType
data Pointer t

newtype Exp t = E (IExp NoType)
newtype Var t = V VarName


--------------------------------
-- Program construction monad --
--------------------------------
data MState = MState
              { params :: [VarName]
              , varCount :: Int
              , statements :: Statements () NoType
              }
initialState :: MState
initialState = MState
               { params = []
               , varCount = 0
               , statements = []
               } 

data Thread
data Step t 

type Warp  = Step Thread
type Block = Step Warp
type Grid  = Step Block

type Program lvl x = State MState x

generateKernel :: String -> Program lvl () -> Kernel NoType
generateKernel name m =
  let finalState = runProgram m initialState
  in Kernel { kernelName = name
            , kernelParams = params finalState
            , kernelBody = statements finalState
            }

runProgram :: Program lvl () -> MState -> MState
runProgram m init' =
  let finalState = execState m init'
  in finalState { statements = reverse (statements finalState) }

addStmt :: Statement () NoType -> Program lvl ()
addStmt stmt =
  modify (\s -> (s {statements = (stmt, ()) : statements s }))

newVar :: Type t -> String -> Program lvl VarName
newVar (T ty) name = do
  c <- gets varCount
  modify (\s -> s { varCount = 1 + varCount s })
  return (name ++ "_" ++ show c, ty) -- the underscore is important!


----------------------
-- Variable binding --
----------------------

-- Variable binder. Creates a fresh variable, adds a declaration
-- w. initialiser and passes it on
let_ :: String -> Type t -> Exp t -> Program lvl (Exp t)
let_ name ty (E e) = do
  v <- newVar ty name
  addStmt (Decl v e)
  return (E (VarE v NoType))

letVar :: String -> Type t -> Exp t -> Program lvl (Var t)
letVar name ty (E e) = do
  v <- newVar ty name
  addStmt (Decl v e)
  return (V v)

addParam :: String -> Type t -> Program lvl (Var t)
addParam name ty = do
  v <- newVar ty name
  modify (\s -> s { params = v : params s })
  return (V v)

var :: Var t -> Exp t
var (V v) = (E (VarE v NoType))
----------------
-- Statements --
----------------

-- I think these two are wrong, we should not just start with an
-- initial state, the varCount at least has to be passed on.

-- construct a for loop, where the body is generated by a function
-- taking the index variable as parameter
for :: Exp Int -> (Exp Int -> Program lvl ()) -> Program lvl ()
for ub f = do
  i <- newVar int "i"
  let_ "ub" int ub >>= (\(E upperbound) -> do
    let body = statements $ runProgram (f (E $ VarE i NoType)) initialState
    addStmt $ For i upperbound body)

iff :: Exp Bool -> (Program lvl (), Program lvl ()) -> Program lvl ()
iff (E cond) (f1, f2) =
  addStmt $ If cond (statements $ runProgram f1 initialState)
                    (statements $ runProgram f2 initialState)

-- distrPar :: Level -> Exp Int -> (Exp Int -> Program ()) -> Program ()
-- distrPar lvl ub f = do
--   i <- newVar int "i"
--   let_ "ub" int ub >>= (\(E upperbound) -> do
--     let body = statements $ runProgram (f (E $ VarE i NoType)) initialState
--     addStmt $ DistrPar lvl i upperbound body)

-- forAll :: Level -> Exp Int -> (Exp Int -> Program ()) -> Program ()
-- forAll lvl ub f = do
--   i <- newVar int "i"
--   let_ "ub" int ub >>= (\(E upperbound) -> do
--     let body = statements $ runProgram (f (E $ VarE i NoType)) initialState
--     addStmt $ ForAll lvl i upperbound body)


-- assign variable, and add to current list of operators
assign :: Var t -> Exp t -> Program Thread ()
assign (V n) (E e) = addStmt (Assign n e)

(<==) :: Var t -> Exp t -> Program Thread ()
n <== e = assign n e

syncGlobal :: Program lvl ()
syncGlobal =  addStmt SyncLocalMem

syncLocal :: Program lvl ()
syncLocal =  addStmt SyncGlobalMem

-- assign to an array
assignArray :: Var (Pointer t) -> Exp Int -> Exp t -> Program Thread ()
assignArray (V n) (E idx) (E e) = addStmt (AssignSub n idx e)

-----------------
--    Types    --
-----------------
int :: Type Int
int = T CInt32

double :: Type Double
double = T CDouble

bool :: Type Bool
bool = T CBool

word8 :: Type Word8
word8 = T CWord8

word32 :: Type Word32
word32 = T CWord32

pointer :: [Attribute] -> Type t ->  Type (Pointer t)
pointer attr (T t) = T (CPtr attr t)

-----------------
-- Expressions --
-----------------
class Scalar t where
  constant :: t -> Exp t

instance Scalar Int where
  constant = E . IntE

instance Scalar Double where
  constant = E . DoubleE

instance Scalar Bool where
  constant = E . BoolE

instance Scalar Word32 where
  constant = E . Word32E

instance Scalar Word8 where
  constant = E . Word8E

if_ :: Exp Bool -> Exp t -> Exp t -> Exp t
if_ (E econd) (E etrue) (E efalse) =
  E (IfE econd etrue efalse NoType)

(?) :: Exp Bool -> (Exp t, Exp t) -> Exp t
econd ? (e0,e1) = if_ econd e0 e1

index :: Var (Pointer t) -> Exp Word32 -> Exp t
index (V n) (E e) = E (IndexE n e)

-- (!) :: Var (Pointer t) -> Exp Word32 -> Exp t
-- (!) = index

-- TODO: This could be better
-- Maybe replace with i2d, b2i, w32_2_i etc?
cast :: Type t2 -> Exp t1 -> Exp t2
cast _ (E e) = E e

globalID :: Exp Int
globalID = E GlobalID

localID :: Exp Int
localID = E LocalID

workgroupID :: Exp Int
workgroupID = E GroupID

localSize :: Exp Int
localSize = E LocalSize

numWorkgroups :: Exp Int
numWorkgroups =  E NumGroups

-----------------
--  Operators  --
-----------------

instance Num (Exp Int) where
  (E e0) + (E e1) = E (BinOpE AddI e0 e1)
  (E e0) * (E e1) = E (BinOpE MulI e0 e1)
  negate (E e0)   = E (UnaryOpE NegateInt e0)
  abs (E e0)   = E (UnaryOpE AbsI e0)
  signum e0 = (e0 `lti` 0) ? (-1,
                              (e0 `gti` 0) ? (1, 0))
  fromInteger = constant . fromIntegral

-- instance Num (Exp Word32) where
  -- (E e0) + (E e1) = E (BinOpE AddI e0 e1)
  -- (E e0) * (E e1) = E (BinOpE MulI e0 e1)
  -- negate (E e0)   = E (UnaryOpE NegateInt e0)
  -- abs (E e0)   = E (UnaryOpE AbsI e0)
  -- signum e0 = (e0 `lti` 0) ? (-1,
  --                             (e0 `gti` 0) ? (1, 0))
  -- fromInteger = constant . fromIntegral

addi, subi, muli, divi, modi :: Exp Int -> Exp Int -> Exp Int
(E e0) `addi` (E e1) = E (BinOpE AddI e0 e1)
(E e0) `subi` (E e1) = E (BinOpE SubI e0 e1)
(E e0) `muli` (E e1) = E (BinOpE MulI e0 e1)
(E e0) `divi` (E e1) = E (BinOpE DivI e0 e1)
(E e0) `modi` (E e1) = E (BinOpE ModI e0 e1)

instance Num (Exp Double) where
  (E e0) + (E e1) = E (BinOpE AddD e0 e1)
  (E e0) * (E e1) = E (BinOpE MulD e0 e1)
  negate (E e0)   = E (UnaryOpE NegateDouble e0)
  abs (E e0)      = E (UnaryOpE AbsD e0)
  signum e0 = (e0 `ltd` 0) ? (-1,
                              (e0 `gtd` 0) ? (1, 0))
  fromInteger     = constant . fromIntegral

addd, subd, muld, divd :: Exp Double -> Exp Double -> Exp Double
(E e0) `addd` (E e1) = E (BinOpE AddD e0 e1)
(E e0) `subd` (E e1) = E (BinOpE SubD e0 e1)
(E e0) `muld` (E e1) = E (BinOpE MulD e0 e1)
(E e0) `divd` (E e1) = E (BinOpE DivD e0 e1)

lti, ltei, gti, gtei, eqi, neqi :: Exp Int -> Exp Int -> Exp Bool
lti  (E e0) (E e1) = E (BinOpE LtI e0 e1)
ltei (E e0) (E e1) = E (BinOpE LteI e0 e1)
gti  (E e0) (E e1) = E (BinOpE GtI e0 e1)
gtei (E e0) (E e1) = E (BinOpE GteI e0 e1)
eqi  (E e0) (E e1) = E (BinOpE EqI e0 e1)
neqi (E e0) (E e1) = E (BinOpE NeqI e0 e1)

ltd, lted, gtd, gted, eqd, neqd  :: Exp Double -> Exp Double -> Exp Bool
ltd  (E e0) (E e1) = E (BinOpE LtD e0 e1)
lted (E e0) (E e1) = E (BinOpE LteD e0 e1)
gtd  (E e0) (E e1) = E (BinOpE GtD e0 e1)
gted (E e0) (E e1) = E (BinOpE GteD e0 e1)
eqd  (E e0) (E e1) = E (BinOpE EqD e0 e1)
neqd (E e0) (E e1) = E (BinOpE NeqD e0 e1)

land, lor, xor, sll, srl :: Exp Word32 -> Exp Word32 -> Exp Word32
land  (E e0) (E e1) = E (BinOpE Land e0 e1)
lor  (E e0) (E e1) = E (BinOpE Lor e0 e1)
xor  (E e0) (E e1) = E (BinOpE Xor e0 e1)
sll  (E e0) (E e1) = E (BinOpE Sll e0 e1)
srl  (E e0) (E e1) = E (BinOpE Srl e0 e1)

(&&*), (||*) :: Exp Bool -> Exp Bool -> Exp Bool
(E e0) &&* (E e1) = E (BinOpE And e0 e1)
(E e0) ||* (E e1) = E (BinOpE Or e0 e1)


-- ltw, gtw :: Exp Word32 -> Exp Word32 -> Exp Bool
-- ltw  (E e0) (E e1) = undefined
-- gtw  (E e0) (E e1) = undefined

-- divw :: Exp Word32 -> Exp Word32 -> Exp Word32
-- divw (E e0) (E e1) = undefined


-- x `minw` y = (x `ltw` y) ? (x, y)
-- x `maxw` y = (x `gtw` y) ? (x, y)
