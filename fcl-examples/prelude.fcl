sig iota : int -> [int]
fun iota (n : int) = generate n (fn x : int => x)

-- sig zipWith : (a -> b -> c) -> [a] -> [b] -> [c]
fun zipWith (f : int -> int -> int) (a1 : [int]) (a2 : [int]) =
  generate (mini (length a1) (length a2))
    (fn ix : int => f (index a1 ix) (index a2 ix))

-- Split an array at a given point
-- sig splitAt : int -> [a] -> ([a], [a])
fun splitAt (n : int) (arr : [a]) =
  (generate n (fn i : int => index arr i),
   generate (subi (length arr) n) (fn x : int => index arr (addi x n)))

-- sig halve : [a] -> ([a], [a])
fun halve (arr : [a]) = splitAt (divi (length arr) 2) arr

-- sig evenOdds : [a] -> ([a], [a])
fun evenOdds (arr : [a]) =
  let n : int  = length arr
  in let n2 : int = divi n 2
     in
     (generate (subi n n2) (fn ix : int => index arr (muli 2 ix)),
      generate n2     (fn ix : int => index arr (addi (muli 2 ix) 1)))

-- sig splitUp : int -> [a] -> [[a]]
fun splitUp (n : int) (arr : [a]) =
  generate (divi (subi (addi (length arr) n) 1) n)
    (fn i : int => generate n
               (fn j : int => index arr (addi (muli i n) j)))

-- sig coalesce : int -> [a] -> [[a]]
fun coalesce (n : int) (arr : [a]) =
  let s : int = divi (length arr) n
  in generate s (fn i : int =>
       generate n (fn j : int => index arr (addi i (muli s j))))

-- sig seqReduce : (a -> a -> a) -> a -> [a] -> a
fun seqReduce (f : a -> a -> a) (b : a) (array : [a]) =
  let n : int = length array in
  let cond : (int,a) -> bool = fn x : (int,a) => neqi (fst x) n in
  let step : (int,a) -> a  = fn x : (int,a) => (addi (fst x) 1, f (index array (fst x)) (snd x))
  in snd (while cond step (0,b))

-- sig reduce : (a -> a -> a) -> [a] -> [a]
fun reduce (f : a -> a -> a) (arr : [a]) =
  let cond : [a] -> bool = fn arr : [a] => neqi 1 (length arr) in
  let step : [a] -> [a] = fn arr : [a] =>
                            let x : ([a],[a]) = halve arr
                            in zipWith f (fst x) (snd x)
  in concat 1 (map (fn arr : [a] => fixpoint cond step (step arr))
                   (splitUp 512 arr))

-- sig concat : int -> [[a]] -> [a]
fun concat (n : int) (arr : [[a]]) =
  assemble n (fn x : (int, int) => addi (muli (fst x) n) (snd x)) arr
