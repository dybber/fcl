fun sobol_num_bits = 30
fun sobol_divisor = powr 2.0 30.0

fun fromBool b = if b then 1 else 0
fun bit i = shiftLi 1 i
fun testBit x i = neqi 0 (andi x (bit i))
fun grayCode x = xori x (shiftRi x 1)

fun xor x y = xori x y
fun mul x y = muli x y

-- Two direction vectors
fun sobol_dirVs =
  [[536870912,268435456,134217728,67108864,33554432,
    16777216,8388608,4194304,2097152,1048576,524288,
    262144,131072,65536,32768,16384,8192,4096,2048,
    1024,512,256,128,64,32,16,8,4,2,1],
   [536870912,805306368,671088640,1006632960,570425344,
    855638016,713031680,1069547520,538968064,808452096,
    673710080,1010565120,572653568,858980352,715816960,
    1073725440,536879104,805318656,671098880,1006648320,
    570434048,855651072,713042560,1069563840,538976288,
    808464432,673720360,1010580540,572662306,858993459]]

fun xorInds ix dirVec =
  let bitVec = generate sobol_num_bits
                 (fn i => fromBool (testBit (grayCode ix) i))
  in seqReduce xor 0 (zipWith mul dirVec bitVec)

fun sobolIndI dirVec ix =
  map (xorInds ix) dirVec

fun sobolIndR dirVec ix =
  let arri = sobolIndI dirVec ix
  in map (fn i => divr (i2d i) sobol_divisor) arri

-- Find first set
fun ffs ix =
  let cond = fn v => neqi 0 (andi (snd v) 1) in
  let step = fn v => (addi (fst v) 1, shiftRi (snd v) 1)
  in fst (while cond step (0, ix))

fun sobolRecI dirVs prev n =
  let bit_ = ffs n in
  let dir_vs = map (fn xs => index xs bit_) dirVs
  in zipWith xor prev dir_vs

-- TODO, implementer polymorfisk scan
-- Giver fejl da seqReduce kun er implementeret for int -> int -> int
fun scanl = seqReduce

fun sobolRecMap dirVs lu =
  let l = fst lu in
  let u = snd lu in
  let first = sobolIndI dirVs l in
  let norm = fn x => divr (i2d x) sobol_divisor in
  let range = generate (subi u l) (fn i => addi i l)
  in  scanl (sobolRecI dirVs) first range
