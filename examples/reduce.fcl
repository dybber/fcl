fun add (a : int) (b : int) = addi a b

fun red1 (splitSize : int) (f : int -> int -> int) (arr : [int]) =
  let cond : [int] -> bool = fn arr : [int] => neqi 1 (length arr) in
  let step : [int] -> [int] = fn arr : [int] =>
                            let x : ([int],[int]) = halve arr
                            in zipWith f (fst x) (snd x)
  in concat 1 (map (fn arr : [int] => while cond step arr)
                   (splitUp splitSize arr))

-- Here we take one step before starting the loop, to do some actual
-- work before materialization.
fun red2 (splitSize : int) (f : int -> int -> int) (arr : [int]) =
  let cond : [int] -> bool = fn arr : [int] => neqi 1 (length arr) in
  let step : [int] -> [int] = fn arr : [int] =>
                            let x : ([int],[int]) = halve arr
                            in zipWith f (fst x) (snd x)
  in concat 1 (map (fn arr : [int] => while cond step (step arr))
                   (splitUp splitSize arr))

fun red1add = red1 512 add
fun red2add = red1 512 add

kernel red1add
kernel red2add
