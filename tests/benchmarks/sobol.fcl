-- Find first set (using OpenCL built-in clz: count leading zeros)
sig ffz : int -> int
fun ffz x =
  let y = addi x 1
  in subi 31 (clz (andi y (negatei y)))

sig grayCode : int -> int
fun grayCode i = xor i (srl i 1)

sig sobol_num_bits : int
val sobol_num_bits = 30

sig sobolInd : int -> [int] -> [int]<thread>
fun sobolInd ix dirVec =
  let bitVec = mapPull (fn i => b2i (testBit (grayCode ix) i))
                       (iota sobol_num_bits)
  in foldl xor 0 (zipWith muli dirVec bitVec)

-- sig sobolInd1D : int -> [int] -> [int]
-- fun sobolInd1D n dirVec = mapPull (fn ix => sobolInd ix dirVec) (iota n)

--sig sobolInd1DBlock : [int] -> [int] -> Program <block> [int]<block>
fun sobolInd1DBlock dirVec indices =
  mapPull (fn ix => sobolInd ix dirVec) indices
   |> mapPull (return <thread>)
   |> concat<thread> 1

--sig sobolInd1DGrid : int -> [int] -> Program <grid> [int]<grid>
fun sobolInd1DGrid n dirVec =
  splitUp 4096 (pad 4096 0 (iota n))
   |> mapPull (sobolInd1DBlock dirVec)
   |> concat<block> 4096

--sig sobolIndND : int -> [[int]] -> [[int]]
fun sobolIndND n dirVs = mapPull (sobolInd1DGrid n) dirVs

-- Alternative version
--   sig sobolIndND : int -> [[int]] -> [[int]]
--   fun sobolIndND n dirVs = mapPull (fn ix => mapPull (sobolInd ix) dirVs) (iota n)

sig sobolRec : [int] -> int -> int -> int
fun sobolRec dirVec previous ix = xor previous (index dirVec (ffz ix))

sig sobolRec1D : int -> int -> [int] -> Program <thread> [int]<thread>
fun sobolRec1D startIx n dirVs = 
  do<thread>
   { initial <- force<thread> (sobolInd startIx dirVs)
   ; return<thread> (scanl (sobolRec dirVs) (index initial 0) (range startIx (subi (addi startIx n) 2)))
   }

sig sobolRec1DChunked : int -> int -> [int] -> Program <block> [int]<block>
fun sobolRec1DChunked chunkSize n dirVec =
  mapPull (muli chunkSize) (range 0 (divi n chunkSize))
   |> (mapPull (fn i => sobolRec1D i chunkSize dirVec))
   |> concat<thread> chunkSize 

-- sig sobolRecND : int -> [[int]] -> [[int]<thread>]
-- fun sobolRecND n dirVs = mapPull (sobolRec1D 0 n) dirVs

-- sig sobolSkip : [int] -> int -> int -> int -> int
-- fun sobolSkip dirVec p prev n =
--   let q_n = ffz (ori n (subi (powi 2 p) 1))
--   in xori prev
--           (xori (index dirVec (subi p 1))
--                 (index dirVec q_n))

-- sig sobolSkipPart : int -> int -> [int] -> int -> [int]<thread>
-- fun sobolSkipPart logskip steps dirVec initial =
--   let stepSize = powi 2 logskip
--   in scanl (sobolSkip dirVec logskip)
--            initial
--            (mapPull (muli stepSize) (iota (subi steps 1)))

-- sig sobolSkip1D : int -> int -> [int] -> [[int]<thread>]
-- fun sobolSkip1D logskip steps dirVec =
--   let stepSize = powi 2 logskip in
--   let initials = sobolInd1D stepSize dirVec
--   in mapPull (sobolSkipPart logskip steps dirVec) initials

-- Normalise to floating point [0;1]
sig sobol_divisor : double
val sobol_divisor = i2d (powi 2 sobol_num_bits)

-- -- Convert a sobol number to floating point in the interval [0,1]

sig normalise : int -> double
fun normalise x = divr (i2d x) sobol_divisor

sig normaliseND : [[int]] -> [[double]]
val normaliseND = mapPull (mapPull normalise)

sig iterations : int
val iterations = 50

-- status: works (in interpreter)
-- sig testSobolIndND : [[double]]
-- val testSobolIndND = normaliseND (sobolIndND iterations sobol_dirVs)

-- -- status: works (in interpreter)
-- sig testSobolRecND : [[double]<thread>]
-- fun testSobolRecND = mapPull (mapPush normalise) (sobolRecND iterations sobol_dirVs)

-- -- status:
-- --   * generates right numbers
-- --   * still needs to be reordered (but written coalesced),
-- --   * needs to support higher dimensions (now only generates first dimension)
-- sig testSobolSkip1D : [[int]<thread>]
-- fun testSobolSkip1D =
--   let vec = index sobol_dirVs 0
--   in sobolSkip1D 3 6 vec

-- fun main = testSobolIndND
-- fun main = sobolIndND iterations sobol_dirVs
-- fun main = testSobolRecND
sig main : Program <grid> [int]
val main =
  do<grid>
   { directionVectors <- readIntCSV "sobol_direction_vectors.csv"
   ; arr <- sobolInd1DGrid (1024*4096) (take 30 directionVectors)
   ; forceAndPrint 100 arr
   }
     
  --testSobolSkip1D

