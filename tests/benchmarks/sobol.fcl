-- Find first set (using OpenCL built-in clz: count leading zeros)
sig ffz : int -> int
fun ffz x =
  let y = addi x 1
  in subi 31 (clz (andi y (0 - y)))

sig grayCode : int -> int
fun grayCode i = xor i (srl i 1)

sig sobol_num_bits : int
val sobol_num_bits = 30

-- Single sobol number, given index and direction vector
sig sobolInd : int -> [int] -> [int]<thread>
fun sobolInd ix dirVec =
  let bitVec = mapPull (fn i => b2i (testBit (grayCode ix) i))
                       (iota sobol_num_bits)
  in foldl xor 0 (zipWith muli dirVec bitVec)

-- Sobol numbers for all numbers in indices array
sig sobolInd1DPart : [int] -> [int] -> Program <block> [int]<block>
fun sobolInd1DPart dirVec indices =
  mapPull (fn ix => return<thread> (sobolInd ix dirVec)) indices
   |> concat<thread> 1

-- Length 'n' 1D sobol sequence, given n and direction vector
sig sobolInd1DBlock : int -> [int] -> Program <block> [int]<block>
fun sobolInd1DBlock n dirVec = sobolInd1DPart dirVec (iota n)

-- Full grid-computation, computing a single sequence using multiple blocks
sig sobolInd1DGrid : int -> [int] -> Program <grid> [int]<grid>
fun sobolInd1DGrid n dirVec =
  splitUp 4096 (pad 4096 0 (iota n))
   |> mapPull (sobolInd1DPart dirVec)
   |> concat<block> 4096

sig sobolIndND : int -> [[int]] -> [Program <block> [int]<block>]
fun sobolIndND n dirVecs =
  dirVecs
   |> mapPull (sobolInd1DBlock n)

-- Full grid computation, computing a single sequence using a single block
sig sobolIndNDGrid : int -> [[int]] -> Program <grid> [int]<grid>
fun sobolIndNDGrid n dirVecs =
   mapPull (sobolInd1DBlock n) dirVecs
   |> concat<block> n

sig sobolRec : [int] -> int -> int -> int
fun sobolRec dirVec previous ix = xor previous (index dirVec (ffz ix))

sig sobolRec1D : int -> int -> [int] -> Program <thread> [int]<thread>
fun sobolRec1D startIx n dirVs =
  do<thread>
   { initial <- force<thread> (sobolInd startIx dirVs)
   ; return<thread> (scanl (sobolRec dirVs) (index initial 0) (range startIx ((startIx + n) - 2)))
   }

sig sobolRec1DChunked : int -> int -> [int] -> Program <block> [int]<block>
fun sobolRec1DChunked chunkSize n dirVec =
  mapPull (muli chunkSize) (iota (1 + (n / chunkSize)))
   |> mapPull (fn i => sobolRec1D i chunkSize dirVec)
   |> concat<thread> chunkSize

sig sobolRecND : int -> [[int]] -> Program <grid> [int]<grid>
fun sobolRecND n dirVs =
  mapPull (sobolRec1DChunked 64 n) dirVs
   |> concat<block> n

sig iterations : int
val iterations = 50

-- Normalise to floating point [0;1]
sig sobol_divisor : double
val sobol_divisor = 1073741824.0 --(powi 2 sobol_num_bits)

-- Convert a sobol number to floating point in the interval [0,1]
sig normalise : int -> double
fun normalise x = divd (i2d x) sobol_divisor

sig normal : Program <grid> [int]<grid> -> Program <grid> [double]<grid>
val normal = liftM<grid> (mapPush<grid> (const normalise))

sig sobolIndNDDouble : int -> [[int]] -> Program <grid> [double]<grid>
fun sobolIndNDDouble n dirVec = normal (sobolIndNDGrid n dirVec)

sig sobolRecNDDouble : int -> [[int]] -> Program <grid> [double]<grid>
fun sobolRecNDDouble n dirVec = normal (sobolRecND n dirVec)

sig main : Program <grid> unit
val main =
  let n = 100000 in
  do<grid>
   { directionVectors <- readIntCSV "sobol_direction_vectors.csv"
   -- ; arr1 <- sobolInd1DGrid n (take sobol_num_bits directionVectors)
   -- ; forceAndPrint n arr1
   ; arr2 <- sobolIndNDDouble n (splitUp sobol_num_bits directionVectors)
   ; forceAndPrintDouble (2*n) arr2
   -- ; arr3 <- sobolRecNDDouble n (splitUp sobol_num_bits directionVectors)
   -- ; forceAndPrintDouble (2*n) arr3
   ; benchmark 100 (forceM<grid> (sobolIndNDDouble n (splitUp sobol_num_bits directionVectors)))
   -- ; benchmark 100 (forceM<grid> (sobolRecNDDouble n (splitUp sobol_num_bits directionVectors)))
   ; return<grid> ()
   }

