-- Reduce 1: evenOdds. Assumes associativity.
sig evenOdds : ['a] -> (['a], ['a])
fun evenOdds arr =
  let n = lengthPull arr in
  let n2 = divi n 2
  in (generatePull (n-n2) (fn ix => index arr (2*ix)),
      generatePull n2     (fn ix => index arr (2*ix + 1)))

sig reduceBlockNoncommutative : <lvl> -> ('a -> 'a -> 'a) -> ['a] -> Program <lvl> ['a]<lvl>
fun reduceBlockNoncommutative <lvl> f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = evenOdds arr
                       in return <lvl> (push <lvl> (zipWith f (fst x) (snd x)))
  in do { a <- while cond step (step arr)
        ; return <lvl> (push <lvl> a)
        }

-- Reduce 2: halve. Assumes commutativity + associativity.
sig reduceBlock : <lvl> -> ('a -> 'a -> 'a) -> ['a] -> Program <lvl> ['a]<lvl>
fun reduceBlock <lvl> f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = halve arr
                       in return <lvl> (push <lvl> (zipWith f (fst x) (snd x)))
  in do { a <- while cond step (step arr)
        ; return <lvl> (push <lvl> a)
        }

-- Pad array with a neutral element
sig pad : int -> 'a -> ['a] -> ['a]
fun pad divisor neutralElement arr =
  let n = lengthPull arr in
  let extension = subi divisor (modi n divisor) in
  let newlength = n + extension
  in generatePull newlength
       (fn i => if lti i n
                then index arr i
                else neutralElement)

-- Reduce array partially by one kernel invocation
sig reducePart : ('a -> 'a -> 'a) -> 'a -> ['a] -> Program <grid> ['a]<grid>
fun reducePart f neutralElement arr =
 let workPerBlock = 2 * #BlockSize in
 let paddedArray = pad workPerBlock neutralElement arr     
 in concatMap 1 (reduceBlock <block> f) (splitUp workPerBlock paddedArray)

sig main : Program <grid> unit
fun main = 
 do { arr <- reducePart addi 0 (generatePull (2048*2048) (fn i => i))
    ; forceAndPrint 100 arr
    ; benchmark 10 arr
    }


-- Full reduction

-- TODO:
---- to benchmark, it should return a push-array
------- should while return a push-array?
---- while does not support interleaving. Between each iteration
---- the size of the array can shrink. How do we shrink a push-array
---- with an interleave around?
sig reduce : ('a -> 'a -> 'a) -> 'a -> ['a] -> Program <grid> ['a]
fun reduce f neutralElement arr =
  let cond = fn arr => 1 != lengthPull arr
  in do { a <- while cond (reducePart f neutralElement) (reducePart f neutralElement arr)
        ; return <grid> a
        }

sig main2 : Program <grid> [int]
fun main2 = reduce addi 0 (generatePull (2048*2048) (fn i => i))
