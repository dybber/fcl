sig appendPull : ['a] -> ['a] -> ['a]
fun appendPull a1 a2 =
  let n1 = lengthPull a1 in
  let n2 = lengthPull a2
  in generate (n1+n2)
       (fn ix => if lti ix n1
                 then index a1 ix
                 else index a2 (ix - n1))

sig fan : ('a -> 'a -> 'a) -> ['a] -> ['a]
fun fan op arr =
  let x = halve arr in
  let a1 = fst x in
  let a2 = snd x in
  let c = index a1 (lengthPull a1 - 1)
  in appendPull a1 (mapPull (op c) a2)

sig binsplit2 : int -> ([int] -> [int]) -> int -> [int] -> Program <block> [int]<block>
fun binsplit2 n f iteration arr =
  let c  = 1 << (subi n iteration) in -- number of blocks
  let m  = divi (lengthPull arr) c in -- size of each block
  let lt = c * m in -- total size after
  let h  = fn i => i % m in -- global index -> index inside block
  let g  = fn i => fn j => (divi i m) * m -- block-offset from global index
                           + j             -- index inside block
  in return <block> (push <block> (generate lt (fn i => index (f (generate m (fn j => (index arr (g i j))))) (h i))))

-- block-level scan
sig sklansky : int -> ('a -> 'a -> 'a) -> ['a] -> Program <block> ['a]<block>
fun sklansky n op arr =
  do { a <- power n (binsplit2 (subi n 1) (fan op)) (return <block> (push <block> arr))
     ; return <block> (push <block> a)
     }

sig scan1Block : ('a -> 'a -> 'a) -> ['a] -> Program <grid> ['a]<grid>
fun scan1Block op arr =
  let lgChunkSize = 2
  in concatMap (lengthPull arr) (sklansky lgChunkSize op) (generate 1 (fn i => arr))

sig scanInChunks : int -> ('a -> 'a -> 'a) -> ['a] -> Program <grid> ['a]<grid>
fun scanInChunks lgChunkSize op arr =
  let chunkSize = 1 << lgChunkSize
  in concatMap chunkSize (sklansky lgChunkSize op) (splitUp chunkSize arr)

sig last : ['a] -> 'a
fun last arr = index arr (lengthPull arr - 1)

sig intermediateSums : int -> ['a] -> ['a]
fun intermediateSums lgChunkSize arr =
  let chunkSize = 1 << lgChunkSize
  in mapPull last (splitUp chunkSize arr)

sig main : Program <grid> [int]
fun main =
  do { arr <- scanInChunks 5 (fn a => fn b => a + b) (generate 128 (fn i => i))
     ; arr' <- forceAndPrint 128 arr
     ; arr2 <- scan1Block (fn a => fn b => a + b) (intermediateSums 5 arr')
     ; forceAndPrint 1 arr2
     ; return <grid> arr'
     -- ; b <- forceAndPrint 128 arr
     -- ; forceAndPrint 4 (push <grid> (intermediateSums 5 b))
     }

-- TODO:
------- Fix simplifier/typechecker bug. I guess it's the simplifier that's buggy.
------- (push <grid>, to scan in a single block)
------- or recursion on host?!

