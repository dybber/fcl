-- Find first set (using OpenCL built-in clz: count leading zeros)
sig ffz : int -> int
fun ffz x =
  let y = addi x 1
  in subi 31 (clz (andi y (negatei y)))

sig grayCode : int -> int
fun grayCode i = xori i (shiftRi i 1)

sig sobol_num_bits : int
fun sobol_num_bits = 30

sig sobolInd : int -> [int] -> [int]<thread>
fun sobolInd ix dirVec =
  let bitVec = mapPull (fn i => b2i (testBit (grayCode ix) i))
                       (iota sobol_num_bits)
  in foldl xori 0 (zipWith muli dirVec bitVec)

-- sig sobolInd1D : int -> [int] -> [int]
-- fun sobolInd1D n dirVec = mapPull (fn ix => sobolInd ix dirVec) (iota n)

sig sobolInd1DBlock : [int] -> [int] -> Program <block> [int]<block>
fun sobolInd1DBlock dirVec indices =
  mapPull (fn ix => sobolInd ix dirVec) indices
   |> mapPull (return <block>)
   |> concat 128

sig sobolInd1DGrid : int -> [int] -> Program <grid> [int]<grid>
fun sobolInd1DGrid n dirVec =
  splitUp 4096 (pad 4096 0 (iota n))
   |> mapPull (sobolInd1DBlock dirVec)
   |> concat 4096

-- sig sobolIndND : int -> [[int]] -> [[int]]
-- fun sobolIndND n dirVs = mapPull (sobolInd1D n) dirVs

-- Alternative version
--   sig sobolIndND : int -> [[int]] -> [[int]]
--   fun sobolIndND n dirVs = mapPull (fn ix => mapPull (sobolInd ix) dirVs) (iota n)

-- sig sobolRec : [int] -> int -> int -> int
-- fun sobolRec dirVec previous ix = xori previous (index dirVec (ffz ix))

-- sig sobolRec1D : int -> int -> [int] -> [int]<thread>
-- fun sobolRec1D startIx n dirVs = 
--   let initial = sobolInd startIx dirVs
--   in scanl (sobolRec dirVs) initial (range startIx (subi (addi startIx n) 2))

-- sig sobolRec1DChunked : int -> int -> [int] -> Program <block> [int]<block>
-- fun sobolRec1DChunked chunkSize n dirVec = 
--   concat chunkSize (mapPull (fn i => return <thread> (sobolRec1D i chunkSize dirVec))
--                             (mapPull (muli chunkSize) (range 0 (divi n chunkSize))))

-- sig sobolRecND : int -> [[int]] -> [[int]<thread>]
-- fun sobolRecND n dirVs = mapPull (sobolRec1D 0 n) dirVs

-- sig sobolSkip : [int] -> int -> int -> int -> int
-- fun sobolSkip dirVec p prev n =
--   let q_n = ffz (ori n (subi (powi 2 p) 1))
--   in xori prev
--           (xori (index dirVec (subi p 1))
--                 (index dirVec q_n))

-- sig sobolSkipPart : int -> int -> [int] -> int -> [int]<thread>
-- fun sobolSkipPart logskip steps dirVec initial =
--   let stepSize = powi 2 logskip
--   in scanl (sobolSkip dirVec logskip)
--            initial
--            (mapPull (muli stepSize) (iota (subi steps 1)))

-- sig sobolSkip1D : int -> int -> [int] -> [[int]<thread>]
-- fun sobolSkip1D logskip steps dirVec =
--   let stepSize = powi 2 logskip in
--   let initials = sobolInd1D stepSize dirVec
--   in mapPull (sobolSkipPart logskip steps dirVec) initials

-- -- Normalise to floating point [0;1]
-- sig sobol_divisor : double
-- fun sobol_divisor = i2d (powi 2 sobol_num_bits)

-- -- Convert a sobol number to floating point in the interval [0,1]

-- sig normalise : int -> double
-- fun normalise x = divr (i2d x) sobol_divisor

-- sig normaliseND : [[int]] -> [[double]]
-- fun normaliseND = mapPull (mapPull normalise)

-- sig iterations : int
-- fun iterations = 50

-- -- status: works (in interpreter)
-- sig testSobolIndND : [[double]]
-- fun testSobolIndND = normaliseND (sobolIndND iterations sobol_dirVs)

-- -- status: works (in interpreter)
-- sig testSobolRecND : [[double]<thread>]
-- fun testSobolRecND = mapPull (mapPush normalise) (sobolRecND iterations sobol_dirVs)

-- -- status:
-- --   * generates right numbers
-- --   * still needs to be reordered (but written coalesced),
-- --   * needs to support higher dimensions (now only generates first dimension)
-- sig testSobolSkip1D : [[int]<thread>]
-- fun testSobolSkip1D =
--   let vec = index sobol_dirVs 0
--   in sobolSkip1D 3 6 vec

-- fun main = testSobolIndND
-- fun main = sobolIndND iterations sobol_dirVs
-- fun main = testSobolRecND
sig main : Program <grid> [int]
fun main =
  do { directionVectors <- readIntCSV "sobol_direction_vectors.csv"
     ; arr <- sobolInd1DGrid (1024*4096) (take 30 directionVectors)
     ; forceAndPrint 100 arr
     }
     
  --testSobolSkip1D

