-- Transpose without interleave or concat
-- but just with backpermute (which is just a generate and some indexing)

sig transpose : int -> int -> [a] -> [a]
fun transpose rows cols elems =
  generatePull (muli rows cols)
           (fn n =>
              let i = divi n rows in
              let j = modi n rows
              in index elems (addi (muli j rows) i))


-- Split a 2D array (represented as a flat vector) into a 2D array of 2D arrays
-- First argument @splitSize is width and height of tiles
-- Second and third argument is the width and height of the original array
sig splitGrid : int -> int -> int -> [a] -> [[a]]
fun splitGrid splitSize rows cols elems =
  let tileSize = muli splitSize splitSize in
  let n = divi rows splitSize in -- height of outer array
  let m = divi cols splitSize in -- width of outer array
  let mkTile =
        (fn p =>
          fn q =>
             generatePull tileSize
                      (fn k =>
                         let i = divi k splitSize in -- row in inner array
                         let j = modi k splitSize    -- column in inner array
                         in index elems (addi (muli p (muli m tileSize))
                                              (addi (muli q splitSize)
                                                    (addi (muli m (muli splitSize i))
                                                          j)))))
  in generatePull (muli n m)
       (fn i =>
          let p = divi i n in -- row in outer
          let q = modi i n -- column in outer
          in mkTile p q)

sig concatGrid : int -> int -> [<a>level] -> <a>(level+1)
fun concatGrid splitSize  -- width&height of inner array
               cols       -- width&height of outer array
               arr =
    let tileSize = muli splitSize splitSize in
    let rowSize = muli tileSize cols in
    let mkGrid = fn i =>
          let tileRow = divi i rowSize in
          let tileCol = modi (divi i splitSize) cols in
          let tileID = addi (muli tileRow cols) tileCol in
          let x = subi i (muli tileRow rowSize) in
          let innerRow = divi x (muli splitSize cols) in
          let y = subi x (muli innerRow (muli splitSize cols)) in
          let innerCol = modi y splitSize
          in (tileID, addi (muli innerRow splitSize) innerCol)
    in backpermute (muli rowSize cols) mkGrid arr

-- Transpose:
--  - split up in tiles
--  - transpose each tile
--  - force each tile to shared memory
--  - transpose outer array
--  - write back to global memory with concatGrid
sig transposeChunked : int -> int -> int -> [int] -> <int>grid
kernel transposeChunked splitSize rows cols elems =
  splitGrid splitSize rows cols elems
   |> mapPull (transpose splitSize splitSize)
   |> mapPull (fn arr => force (#push<block> arr))  -- force into shared memory
   |> transpose (divi rows splitSize) (divi cols splitSize)
   |> concatGrid splitSize (divi cols splitSize)
   |> (fn arr => #push<block> arr)
