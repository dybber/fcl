
-- red1: evenOdds
-- red2: halve
sig red2 : <lvl> -> ('a -> 'a -> 'a) -> ['a] -> Program <lvl> ['a]<lvl>
fun red2 <lvl> f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = halve arr
                       in push <lvl> (zipWith f (fst x) (snd x))
  in do { a <- while cond step (step arr)
        ; return <lvl> (push <lvl> a)
        }

sig red2Part : ('a -> 'a -> 'a) -> ['a] -> Program <grid> ['a]<grid>
fun red2Part f arr =
 let workPerBlock = 2 * #BlockSize
 in concatMap 1 (red2 <block> f) (splitUp workPerBlock arr)

sig red2Add : [int] -> Program <grid> [int]<grid>
fun red2Add arr = red2Part addi arr

sig main : Program <grid> [int]
fun main =
  do { arr <- red2Add (generatePull 511 (fn i => i))
     -- ; arr2 <- force arr
     -- ; arr3 <- red2Add arr2
     ; forceAndPrint 1 arr
     }


-- Current problems:
---- splitUp does not work on arrays that does not divide
---- no "push" on Grid-level
---- no conditionals on host-level


-- sig reduce : [int] -> Program <host> [int]<host>
-- fun reduce arr = concat (map red2Add (splitUp workPerDevice arr))

-- sig main : Program <host> ()
-- fun main =
--   do { input <- readIntCSV "blah.csv" ; -- [int]
--        arrpush <- reduce input; -- Program <host> [int]<host>
--        arr <- force arrpush; -- [int]
--        printIntArray arr;
--      }

-- printIntArray : [int] -> Program <host> ()
