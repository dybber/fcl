
-- red1: evenOdds
-- red2: halve

sig red2 : (a -> a -> a) -> [a] -> [a]<lvl>
fun red2 f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = halve arr
                       in #push<block> (zipWith f (fst x) (snd x))
  in #push<block> (while cond step (step arr))

sig red2Part : (a -> a -> a) -> [a] -> [a]<grid>
fun red2Part f arr =
 let workPerBlock = 2 * #BlockSize
 in concatMap 1 (red2 f) (splitUp workPerBlock arr)

sig red2Add : [int] -> [int]<lvl>
kernel red2Add arr = red2Part addi arr
  config #BlockSize = 128

-- red3: halve + cutoff w. seq reduce on remainder
-- red4: initial sequential reduce (chunks of 8) + red3 on rest
-- red5: red4 - but in coalesced version
-- red6: red5 but chunks of 16
-- red7: red5 but chunks of 32

-- reduceLocal/reduceBlock/reduceGrid: using the hierarchy


sig reduceWarp : (a -> a -> a) -> [a] -> [a]<warp>
fun reduceWarp f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = halve arr
                       in #push<warp> (zipWith f (fst x) (snd x))
  in #push<warp> (while cond step (step arr))

sig reduceLocal : (a -> a -> a) -> [a] -> [a]<lvl>
fun reduceLocal f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = halve arr
                       in #push<block> (zipWith f (fst x) (snd x))
  in #push<block> (while cond step (step arr))

sig reduceBlock : (a -> a -> a) -> [a] -> [a]<block>
fun reduceBlock f arr =
  splitUp 32 arr
   |> mapPull (reduceWarp f)
   |> concat 32
   |> force
   |> reduceLocal f

sig reduceGrid : (a -> a -> a) -> [a] -> [a]<grid>
fun reduceGrid f arr =
  splitUp 512 arr
   |> mapPull (reduceBlock f)
   |> concat 512


sig reduceGridAdd : [int] -> [int]<lvl>
kernel reduceGridAdd arr = reduceGrid addi arr
  config #BlockSize = 256

fun main = red2Add (generatePull 2048 (fn i => i))
