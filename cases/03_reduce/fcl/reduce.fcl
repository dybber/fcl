
-- red1: evenOdds
-- red2: halve
sig red2 : <lvl> -> ('a -> 'a -> 'a) -> ['a] -> Program <lvl> ['a]<lvl>
fun red2 <lvl> f arr =
  let cond = fn arr => 1 != lengthPull arr in
  let step = fn arr => let x = halve arr
                       in push <lvl> (zipWith f (fst x) (snd x))
  in bind (while cond step (step arr)) (fn a => return <lvl> (push <lvl> a))

sig red2Part : ('a -> 'a -> 'a) -> ['a] -> Program <grid> ['a]<grid>
fun red2Part f arr =
 let workPerBlock = 2 * #BlockSize
 in concatMap 1 (red2 <block> f) (splitUp workPerBlock arr)

sig red2Add : [int] -> Program <grid> [int]<grid>
fun red2Add arr = red2Part addi arr

fun main = bind (red2Add (generatePull 2048 (fn i => i))) (fn arr => forceAndPrint 4 arr)

-- sig reduce : [int] -> Program <host> [int]<host>
-- fun reduce arr = concat (map red2Add (splitUp workPerDevice arr))

-- sig main : Program <host> ()
-- fun main =
--   do { input <- readIntCSV "blah.csv" ; -- [int]
--        arrpush <- reduce input; -- Program <host> [int]<host>
--        arr <- force arrpush; -- [int]
--        printIntArray arr;
--      }

-- printIntArray : [int] -> Program <host> ()
