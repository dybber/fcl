sig reverse : [a] -> [a]
fun reverse arr =
  let n = lengthPull arr
  in generatePull n (fn i => index arr (n - i - 1))

sig reverseBlock : [int] -> [int]<block>
kernel reverseBlock arr = push <block> (reverse arr)

sig distributeReverse : int -> [a] -> [a]<grid>
fun distributeReverse splitSize arr =
  splitUp splitSize arr
   |> mapPull (fn arr2 => push <block> (force (push <block> (reverse arr2))))
   |> reverse
   |> concat splitSize

sig reverseKernel : [int] -> [int]<grid>
kernel reverseKernel arr = distributeReverse #BlockSize arr


sig simpleReverse : int -> [a] -> [a]<grid>
fun simpleReverse splitSize arr =
  splitUp splitSize arr
   |> mapPull (fn arr2 => push <block> (reverse arr2))
   |> reverse
   |> concat splitSize

sig simpleReverseKernel : [int] -> [int]<grid>
kernel simpleReverseKernel arr = simpleReverse #BlockSize arr
  config #BlockSize = 256
