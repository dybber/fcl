sig id : a -> a
fun id x = x

sig iota : int -> [int]
fun iota n = generatePull n (fn x => x)

sig zipWith : (a -> b -> c) -> [a] -> [b] -> [c]
fun zipWith f a1 a2 =
  generatePull (mini (lengthPull a1) (lengthPull a2))
    (fn ix => f (index a1 ix) (index a2 ix))

sig backpermute : int -> (int -> (int, int)) -> [[a]] -> [a]
fun backpermute totalSize f array =
  generatePull totalSize
    (fn ix => let ix0 = f ix
              in index (index array (fst ix0)) (snd ix0))

-- Split an array at a given point
sig splitAt : int -> [a] -> ([a], [a])
fun splitAt n arr =
  (generatePull n (fn i => index arr i),
   generatePull (subi (lengthPull arr) n) (fn x => index arr (addi x n)))

sig halve : [a] -> ([a], [a])
fun halve arr = splitAt (divi (lengthPull arr) 2) arr

sig evenOdds : [a] -> ([a], [a])
fun evenOdds arr =
  let n  = lengthPull arr
  in let n2 = divi n 2
     in
     (generatePull (subi n n2) (fn ix => index arr (muli 2 ix)),
      generatePull n2     (fn ix => index arr (addi (muli 2 ix) 1)))

sig splitUp : int -> [a] -> [[a]]
fun splitUp n arr =
  generatePull (divi (lengthPull arr) n)
    (fn i => generatePull n
       (fn j => index arr (addi (muli i n) j)))

sig coalesce : int -> [a] -> [[a]]
fun coalesce n arr =
  let s = divi (lengthPull arr) n
  in generatePull s (fn i =>
       generatePull n (fn j => index arr (addi i (muli s j))))

sig seqReduce : (a -> a -> a) -> a -> [a] -> a
fun seqReduce f b array =
  let n = lengthPull array in
  let cond = fn x => neqi (fst x) n in
  let step  = fn x => (addi (fst x) 1,
                       f (index array (fst x)) (snd x))
  in snd (whileSeq cond step (0,b))

sig concatMap : int -> (a -> <b>lvl) -> [[a]] -> <b>(1+lvl)
fun concatMap size f arr = concat size (mapPull f arr)

sig reduceBlock : (a -> a -> a) -> [a] -> <a>lvl
fun reduceBlock f arr =
  let cond = fn arr => eqi 1 (lengthPull arr) in
  let step = fn arr => let x = halve arr
                       in #push<block> (zipWith f (fst x) (snd x))
  in #push<block> (while cond step (step arr))

sig reducePart : (a -> a -> a) -> [a] -> <a>grid
fun reducePart f arr = concatMap 1 (reduceBlock f) (splitUp 512 arr)
