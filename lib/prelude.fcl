sig id : a -> a
fun id x = x

sig iota : int -> [int]
fun iota n = generate n (fn x => x)

sig zipWith : (a -> b -> c) -> [a] -> [b] -> [c]
fun zipWith f a1 a2 =
  generate (mini (length a1) (length a2))
    (fn ix => f (index a1 ix) (index a2 ix))

sig backpermute : int -> (int -> (int, int)) -> [[a]] -> [a]
fun backpermute totalSize f array =
  generate totalSize
    (fn ix => let ix0 = f ix
              in index (index array (fst ix0)) (snd ix0))

-- Split an array at a given point
sig splitAt : int -> [a] -> ([a], [a])
fun splitAt n arr =
  (generate n (fn i => index arr i),
   generate (subi (length arr) n) (fn x => index arr (addi x n)))

sig halve : [a] -> ([a], [a])
fun halve arr = splitAt (divi (length arr) 2) arr

sig evenOdds : [a] -> ([a], [a])
fun evenOdds arr =
  let n  = length arr
  in let n2 = divi n 2
     in
     (generate (subi n n2) (fn ix => index arr (muli 2 ix)),
      generate n2     (fn ix => index arr (addi (muli 2 ix) 1)))

sig splitUp : int -> [a] -> [[a]]
fun splitUp n arr =
  generate (divi (subi (addi (length arr) n) 1) n)
    (fn i => generate n
       (fn j => index arr (addi (muli i n) j)))

sig coalesce : int -> [a] -> [[a]]
fun coalesce n arr =
  let s = divi (length arr) n
  in generate s (fn i =>
       generate n (fn j => index arr (addi i (muli s j))))

sig seqReduce : (a -> a -> a) -> a -> [a] -> a
fun seqReduce f b array =
  let n = length array in
  let cond = fn x => neqi (fst x) n in
  let step  = fn x => (addi (fst x) 1,
                       f (index array (fst x)) (snd x))
  in snd (while cond step (0,b))

sig reduceBlock : (a -> a -> a) -> [a] -> [a]
fun reduceBlock f arr =
  let cond = fn arr => neqi 1 (length arr) in
  let step = fn arr => let x = halve arr
                       in zipWith f (fst x) (snd x)
  in while cond step (step arr)

sig reducePart : (a -> a -> a) -> [a] -> [a]
fun reducePart f arr =
   concat 1 (map (reduceBlock f) (splitUp 512 arr))

